<?php
/**
 * JSV: JSON Schema Validator
 * 
 * @fileOverview A JavaScript implementation of a extendable, fully compliant JSON Schema validator.
 * @author Gregory Beaver greg@chiaraquartet.net
 * @author Gary Court gary.court@gmail.com
 * @version 3.5
 * @see http://github.com/garycourt/uri-js Ported from JSV
 */

/*
 * Copyright 2010 Gary Court. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 * 
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 * 
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Gary Court or the JSON Schema specification.
 */

/*jslint white: true, sub: true, onevar: true, undef: true, eqeqeq: true, newcap: true, immed: true, indent: 4 */
namespace JsonSchema;
include 'uri/Uri.php';
include 'uri/UriCache.php';
include 'JsonSchemaDraft01.php';
function is_json_object($i)
{
    if (is_object($i)) {
        return true;
    }
    if (!is_array($i)) {
        return false;
    }
    foreach ($i as $k => $v) {
        if (is_string($k)) {
            return true;
        }
        return false;
    }
}
function is_json_array($i)
{
    if (!is_array($i)) {
        return false;
    }
    foreach ($i as $k => $v) {
        if (is_string($k)) {
            return false;
        }
        return true;
    }
}
//class Exception extends \Exception {}
/**
 * Defines an error, found by a schema, with an instance.
 * This class can only be instantiated by {@link Report#addError}.
 */
class ValidationException extends Exception
{
    
    /**
     * The URI of the instance that has the error.
     * 
     * @name ValidationError.prototype.uri
     * @type String
     */
    
    public $uri;

    /**
     * The URI of the schema that generated the error.
     * 
     * @name ValidationError.prototype.schemaUri
     * @type String
     */
    
    public $schemaUri;
    /**
     * The name of the schema attribute that generated the error.
     * 
     * @name ValidationError.prototype.attribute
     * @type String
     */
    
    public $attribute;
    /**
     * The value of the schema attribute that generated the error.
     * 
     * @name ValidationError.prototype.details
     * @type Any
     */
    public $details;
    
    /**
     * An user-friendly (English) message about what failed to validate.
     * 
     * @name ValidationError.prototype.message
     * @type String
     */
}

/**
 * Reports are returned from validation methods to describe the result of a validation.
 * @see JSONSchema#validate
 * @see Environment#validate
 */
class Report
{
    /**
     * An array of {@link ValidationError} objects that define all the errors generated by the schema against the instance.
     * 
     * @name Report.prototype.errors
     * @type Array
     * @see Report#addError
     */
    protected $errors = array();

    /**
     * A hash table of every instance and what schemas were validated against it.
     * <p>
     * The key of each item in the table is the URI of the instance that was validated.
     * The value of this key is an array of strings of URIs of the schema that validated it.
     * </p>
     * 
     * @name Report.prototype.validated
     * @type Object
     * @see Report#registerValidation
     * @see Report#isValidatedBy
     */
    protected $validated = array();

    /**
     * If the report is generated by {@link Environment#validate}, this field is the generated instance.
     * 
     * @name Report.prototype.instance
     * @type JSONInstance
     * @see Environment#validate
     */
    protected $instance;

    /**
     * If the report is generated by {@link Environment#validate}, this field is the generated schema.
     * 
     * @name Report.prototype.schema
     * @type JSONSchema
     * @see Environment#validate
     */
    protected $schema;

    /**
     * If the report is generated by {@link Environment#validate}, this field is the schema's schema.
     * This value is the same as calling <code>schema.getSchema()</code>.
     * 
     * @name Report.prototype.schemaSchema
     * @type JSONSchema
     * @see Environment#validate
     * @see JSONSchema#getSchema
     */
    protected $schemaSchema;

    private $_checkVars = array('instance' => 1, 'schema' => 1, 'schemaSchema' => 1, 'validated' => 1);

    function __clone()
    {
        $this->errors = array();
    }

    function __get($var)
    {
        if (!isset($this->_checkVars[$var]) || $var !== 'errors') {
            throw new Exception('Invalid Report variable requested: ' . $var);
        }
        return $this->$var;
    }

    function __set($var, $val)
    {
        if (!isset($this->_checkVars[$var])) {
            throw new Exception('Invalid Report variable requested: ' . $var);
        }
        $this->$var = $val;
    }
    
    /**
     * Adds a {@link ValidationException} object to the <a href="#errors"><code>errors</code></a> field.
     * 
     * @param {JSONInstance|String} instance The instance (or instance URI) that is invalid
     * @param {JSONSchema|String} schema The schema (or schema URI) that was validating the instance
     * @param {String} attr The attribute that failed to validated
     * @param {String} message A user-friendly message on why the schema attribute failed to validate the instance
     * @param {Any} details The value of the schema attribute
     */
    
    function addError($instance, $schema, $attr, $message, $details = '')
    {
        $err = new ValidationException($message);
        $err->uri = $instance instanceof JSONInstance ? $instance->getURI() : $instance;
        $err->schemaUri = $schema instanceof JSONInstance ? $schema->getURI() : $schema;
        $err->attribute = $attr;
        $err->details = $details;
        array_push($this->errors, $err);
    }
    
    /**
     * Registers that the provided instance URI has been validated by the provided schema URI. 
     * This is recorded in the <a href="#validated"><code>validated</code></a> field.
     * 
     * @param {String} uri The URI of the instance that was validated
     * @param {String} schemaUri The URI of the schema that validated the instance
     */
    
    function registerValidation($uri, $schemaUri) {
        if (!isset($this->validated[$uri])) {
            $this->validated[$uri] = array($schemaUri);
        } else {
            $this->validated[$uri][] = $schemaUri;
        }
    }
    
    /**
     * Returns if an instance with the provided URI has been validated by the schema with the provided URI. 
     * 
     * @param {String} uri The URI of the instance
     * @param {String} schemaUri The URI of a schema
     * @returns {Boolean} If the instance has been validated by the schema.
     */
    
    function isValidatedBy($uri, $schemaUri)
    {
        return isset($this->validated[$uri]) && in_array($this->validated[$uri], $schemaUri);
    }
}
    
/**
 * A wrapper class for binding an Environment, URI and helper methods to an instance. 
 * This class is most commonly instantiated with {@link Environment#createInstance}.
 * 
 * @name JSONInstance
 */
class JSONInstance
{
    protected $_fd;
    protected $_uri;
    protected $_value;
    protected $_env;

    function getFd()
    {
        return $this->_fd;
    }

    function getUri()
    {
        return $this->_uri;
    }

    function setUri($uri)
    {
        $this->_uri = $uri;
    }

    function getValue()
    {
        return $this->_value;
    }

    function getEnvironment()
    {
        return $this->_env;
    }

    /**
     * @param {Environment} env The environment this instance belongs to
     * @param {JSONInstance|Any} json The value of the instance
     * @param {String} [uri] The URI of the instance. If undefined, the URI will be a randomly generated UUID. 
     * @param {String} [fd] The fragment delimiter for properties. If undefined, uses the environment default.
     */
    
    function __construct(Environment $env, $json, $uri, $fd = null) {
        if ($json instanceof JSONInstance) {
            if (!$fd) {
                $fd = $json->getFd();
            }
            if (!$uri) {
                $uri = $json->getUri();
            }
            $json = $json->getValue();
        }
        
        if (!$uri) {
            $uri = "urn:uuid:" . JSV::randomUUID() . "#";
        } elseif (strpos($uri, ":") === -1) {
            $urimanager = new URI();
            $uri = JSV::formatURI($urimanager->resolve("urn:uuid:" . JSV::randomUUID() . "#", $uri));
        }
        
        $this->_env = $env;
        $this->_value = $json;
        $this->_uri = $uri;
        $this->_fd = $fd ? $fd : $this->_env->getOption("defaultFragmentDelimiter");
    }
    
    /**
     * Returns a resolved URI of a provided relative URI against the URI of the instance.
     * 
     * @param {String} uri The relative URI to resolve
     * @returns {String} The resolved URI
     */
    
    function resolveURI($uri)
    {
        $urimanager = new URI();
        return JSV::formatURI($urimanager->resolve($this->_uri, $uri));
    }
    
    /**
     * Returns an array of the names of all the properties.
     * 
     * @returns {Array} An array of strings which are the names of all the properties
     */
    
    function getPropertyNames()
    {
        return array_keys($this->_value);
    }
    
    /**
     * Returns a {@link JSONInstance} of the value of the provided property name. 
     * 
     * @param {String} key The name of the property to fetch
     * @returns {JSONInstance} The instance of the property value
     */
    
    function getProperty($key)
    {
        $value = isset($this->_value) && is_array($this->_value) && isset($this->_value[$key]) ? $this->_value[$key] : null;
        if ($value instanceof JSONInstance) {
            return $value;
        }
        //else
        return new JSONInstance($this->_env, $value, $this->_uri . $this->_fd . urlencode($key), $this->_fd);
    }
    
    /**
     * Returns all the property instances of the target instance.
     * <p>
     * If the target instance is an Object, then the method will return a hash table of {@link JSONInstance}s of all the properties. 
     * If the target instance is an Array, then the method will return an array of {@link JSONInstance}s of all the items.
     * </p> 
     * 
     * @returns {Object|Array|undefined} The list of instances for all the properties
     */
    
    function getProperties()
    {
        $val = $this->_value;
        if ($val === null) {
            return array();
        }
        $self = $this;
        settype($val, 'array');
        array_walk($val, function (&$value, $key) use ($self) {
            if ($value instanceof JSONInstance) {
                return;
            }
            $value = new JSONInstance($self->getEnvironment(), $value, $self->getUri() . $self->getFd() . urlencode($key), $self->getFd());
        });
        return $val;
    }
    
    /**
     * Returns the JSON value of the provided property name. 
     * This method is a faster version of calling <code>instance.getProperty(key).getValue()</code>.
     * 
     * @param {String} key The name of the property
     * @returns {Any} The JavaScript value of the instance
     * @see JSONInstance#getProperty
     * @see JSONInstance#getValue
     */
    
    function getValueOfProperty($key)
    {
        if ($this->_value) {
            if (!isset($this->_value[$key])) {
                return null;
            }
            if ($this->_value[$key] instanceof JSONInstance) {
                return $this->_value[$key]->getValue();
            }
            return $this->_value[$key];
        }
    }
    
    /**
     * Return if the provided value is the same as the value of the instance.
     * 
     * @param {JSONInstance|Any} instance The value to compare
     * @returns {Boolean} If both the instance and the value match
     */
    
    function equals($instance) {
        if ($instance instanceof JSONInstance) {
            return $this->_value === $instance->getValue();
        }
        //else
        return $this->_value === $instance;
    }
}

    /**
     * This class binds a {@link JSONInstance} with a {@link JSONSchema} to provided context aware methods. 
     */
class JSONSchema extends JSONInstance
{
    protected $_schema;
    protected $_fd;
    protected $_attributes = array();
    /**
     * @param {Environment} env The environment this schema belongs to
     * @param {JSONInstance|Any} json The value of the schema
     * @param {String} [uri] The URI of the schema. If undefined, the URI will be a randomly generated UUID. 
     * @param {JSONSchema|Boolean} [schema] The schema to bind to the instance. If <code>undefined</code>, the environment's default schema will be used. If <code>true</code>, the instance's schema will be itself.
     * @extends JSONInstance
     */
    
    function __construct(Environment $env, $json, $uri = null, $schema = null) {
        parent::__construct($env, $json, $uri);
        
        if ($schema === true) {
            $this->_schema = $this;
        } elseif ($json instanceof JSONSchema && !($schema instanceof JSONSchema)) {
            $this->_schema = $json->getSchema();  //TODO: Make sure cross environments don't mess everything up
        } else {
            if ($schema instanceof JSONSchema) {
                $this->_schema = $schema;
            } else {
                $default = $this->_env->getDefaultSchema();
                if ($default) {
                    $this->_schema = $default;
                } else {
                    $this->_schema = $this->createEmptySchema($this->_env);
                }
            }
        }
        
        //determine fragment delimiter from schema
        $fr = $this->_schema->getValueOfProperty("fragmentResolution");
        if ($fr === "dot-delimited") {
            $this->_fd = ".";
        } else if ($fr === "slash-delimited") {
            $this->_fd = "/";
        }
    }

    /**
     * Creates an empty schema.
     * 
     * @param {Environment} env The environment of the schema
     * @returns {JSONSchema} The empty schema, who's schema is itself.
     */
    
    static function createEmptySchema(Environment $env)
    {
        static $race = 0;
        if ($race) return $this;
        $race = 1; // avoid race condition: endless loop
        $schema = new self($env, new stdClass, null);
        $race = 0;
        $schema->setSchema($schema);
        return $schema;
    }
    
    function setSchema(JSONSchema $schema)
    {
        $this->_schema = $schema;
        $fr = $this->_schema.getValueOfProperty("fragmentResolution");
        if ($fr === "dot-delimited") {
            $this->_fd = ".";
        } else if ($fr === "slash-delimited") {
            $this->_fd = "/";
        }
    }
    
    /**
     * Returns the schema of the schema.
     * 
     * @returns {JSONSchema} The schema of the schema
     */
    
    function getSchema()
    {
        return $this->_schema;
    }
    
    /**
     * Returns the value of the provided attribute name.
     * <p>
     * This method is different from {@link JSONInstance#getProperty} as the named property 
     * is converted using a parser defined by the schema's schema before being returned. This
     * makes the return value of this method attribute dependent.
     * </p>
     * 
     * @param {String} key The name of the attribute
     * @param {Any} [arg] Some attribute parsers accept special arguments for returning resolved values. This is attribute dependent.
     * @returns {JSONSchema|Any} The value of the attribute
     */
    
    function getAttribute($key, $arg = null)
    {
        if (!$arg && array_key_exists($key, $this->_attributes)) {
            return $this->_attributes[$key];
        }
        
        $schemaProperty = $this->_schema->getProperty("properties")->getProperty($key);
        $parser = $schemaProperty->getValueOfProperty("parser");
        $property = $this->getProperty($key);
        if (is_callable($parser)) {
            if (is_object($parser)) {
                $result = $parser($property, $schemaProperty, $arg);
            } else {
                call_user_func($parser, $property, $schemaProperty, $arg);
            }
            if (!$arg && $this->_attributes) {
                $this->_attributes[$key] = $result;
            }
            return $result;
        }
        //else
        return $property->getValue();
    }
    
    /**
     * Returns all the attributes of the schema.
     * 
     * @returns {Object} A map of all parsed attribute values
     */
    
    function getAttributes()
    {
        if (!count($this->_attributes) && is_json_object($this->_value)) {
            $properties = $this->getProperties();
            $schemaProperties = $this->_schema->getProperty("properties");
            $this->_attributes = array();
            foreach ($properties as $key => $val) {
                if (count($schemaProperties)) {
                    $schemaProperty = $schemaProperties->getProperty($key);
                    if ($schemaProperty) {
                        $parser = $schemaProperty->getValueOfProperty("parser");
                    }
                }
                if (is_callable($parser)) {
                    if (is_object($parser)) {
                        $this->_attributes[$key] = $parser($val, $schemaProperty);
                    } else {
                        $this->_attributes[$key] = call_user_func($parser, $val, $schemaProperty);
                    }
                } else {
                    $this->_attributes[$key] = $val->getValue();
                }
            }
        }
        
        return JSV::dirtyClone($this->_attributes);
    }
    
    /**
     * Convenience method for retrieving a link or link object from a schema. 
     * This method is the same as calling <code>schema.getAttribute("links", [rel, instance])[0];</code>.
     * 
     * @param {String} rel The link relationship
     * @param {JSONInstance} [instance] The instance to resolve any URIs from
     * @returns {String|Object|undefined} If <code>instance</code> is provided, a string containing the resolve URI of the link is returned.
     *   If <code>instance</code> is not provided, a link object is returned with details of the link.
     *   If no link with the provided relationship exists, <code>undefined</code> is returned.
     * @see JSONSchema#getAttribute
     */
    
    function getLink($rel, JSONInstance $instance)
    {
        $schemaLinks = $this->getAttribute("links", array($rel, $instance));
        if ($schemaLinks && count($schemaLinks) && $schemaLinks[count($schemaLinks) - 1]) {
            return $schemaLinks[count($schemaLinks) - 1];
        }
    }
    
    /**
     * Validates the provided instance against the target schema and returns a {@link Report}.
     * 
     * @param {JSONInstance|Any} instance The instance to validate; may be a {@link JSONInstance} or any JavaScript value
     * @param {Report} [report] A {@link Report} to concatenate the result of the validation to. If <code>undefined</code>, a new {@link Report} is created. 
     * @param {JSONInstance} [parent] The parent/containing instance of the provided instance
     * @param {JSONSchema} [parentSchema] The schema of the parent/containing instance
     * @param {String} [name] The name of the parent object's property that references the instance
     * @returns {Report} The result of the validation
     */
    
    function validate($instance, Report $report = null, JSONInstance $parent = null, JSONSchema $parentSchema = null, $name = null)
    {
        $validator = $this->_schema->getValueOfProperty("validator");
        
        if (!($instance instanceof JSONInstance)) {
            $instance = $this->getEnvironment()->createInstance($instance);
        }
        
        if (!($report instanceof Report)) {
            $report = new Report();
        }
        
        if (is_callable($validator) && !$report->isValidatedBy($instance->getURI(), $this->getURI())) {
            $report->registerValidation($instance->getURI(), $this->getURI());
            $validator($instance, $this, $this->_schema, $report, $parent, $parentSchema, $name);
        }
        
        return $report;
    }
}

class EnvironmentOptions
{
    public $defaultFragmentDelimiter = '',
           $defaultSchemaURI = '';
    function __set($var, $value)
    {
        throw new Exception('Unknown option value: ' . $var);
    }
    function __get($var)
    {
        throw new Exception('Unknown option value: ' . $var);
    }
}

class Environment
{
    protected $_schemas = array();
    protected $_options;
    protected $_id;
    /**
     * An Environment is a sandbox of schemas thats behavior is different from other environments.
     * 
     * @name Environment
     * @class
     */
    
    function __construct() {
        $this->_id = JSV::randomUUID();
        $this->_options = new EnvironmentOptions;
    }
    
    /**
     * Returns a clone of the target environment.
     * 
     * @returns {Environment} A new {@link Environment} that is a exact copy of the target environment 
     */
    
    function __clone()
    {
        $this->_options = clone $this->_options;
        $this->_schemas = JSV::inherits($this->_schemas);
    }
    
    /**
     * Returns a new {@link JSONInstance} of the provided data.
     * 
     * @param {JSONInstance|Any} data The value of the instance
     * @param {String} [uri] The URI of the instance. If undefined, the URI will be a randomly generated UUID. 
     * @returns {JSONInstance} A new {@link JSONInstance} from the provided data
     */
    
    function createInstance($data, $uri = '')
    {
        $uri = JSV::formatURI($uri);
        
        if ($data instanceof JSONInstance && (!$uri || $data->getURI() === $uri)) {
            return $data;
        }
        //else
        $instance = new JSONInstance($this, $data, $uri);
        
        return $instance;
    }
    
    /**
     * Creates a new {@link JSONSchema} from the provided data, and registers it with the environment. 
     * 
     * @param {JSONInstance|Any} data The value of the schema
     * @param {JSONSchema|Boolean} [schema] The schema to bind to the instance. If <code>undefined</code>, the environment's default schema will be used. If <code>true</code>, the instance's schema will be itself.
     * @param {String} [uri] The URI of the schema. If undefined, the URI will be a randomly generated UUID. 
     * @returns {JSONSchema} A new {@link JSONSchema} from the provided data
     * @throws {InitializationError} If a schema that is not registered with the environment is referenced 
     */
    
    function createSchema($data, $schema = null, $uri = '')
    {
        $uri = JSV::formatURI($uri);
        
        if ($data instanceof JSONSchema && (!$uri || $data->getUri() === $uri) && (!$schema || $data->getSchema()->equals($schema))) {
            return $data;
        }
        
        $instance = new JSONSchema($this, $data, $uri, $schema);
        
        $initializer = $instance->getSchema()->getValueOfProperty("initializer");
        if (is_callable($initializer)) {
            if (is_object($initializer)) {
                $instance = $initializer($instance);
            } else {
                $instance = call_user_func($initializer, $instance);
            }
        }
        
        //register schema
        $this->_schemas[$instance->getUri()] = $instance;
        settype($uri, 'string');
        $this->_schemas[$uri] = $instance;
        
        //build & cache the rest of the schema
        $instance->getAttributes();
        
        return $instance;
    }
    
    /**
     * Creates an empty schema.
     * 
     * @param {Environment} env The environment of the schema
     * @returns {JSONSchema} The empty schema, who's schema is itself.
     */
    
    function createEmptySchema()
    {
        $schema = JSONSchema::createEmptySchema($this);
        $this->_schemas[$schema->getUri()] = $schema;
        return $schema;
    }
    
    /**
     * Returns the schema registered with the provided URI.
     * 
     * @param {String} uri The absolute URI of the required schema
     * @returns {JSONSchema|undefined} The request schema, or <code>undefined</code> if not found
     */
    
    function findSchema($uri)
    {
        if (!isset($this->_schemas[JSV::formatURI($uri)])) {
            return null;
        }
        return $this->_schemas[JSV::formatURI($uri)];
    }
    
    /**
     * Sets the specified environment option to the specified value.
     * 
     * @param {String} name The name of the environment option to set
     * @param {Any} value The new value of the environment option
     */
    
    function setOption($name, $value)
    {
        $this->_options->$name = $value;
    }
    
    /**
     * Returns the specified environment option.
     * 
     * @param {String} name The name of the environment option to set
     * @returns {Any} The value of the environment option
     */
    
    function getOption($name)
    {
        return $this->_options->$name;
    }
    
    /**
     * Sets the default fragment delimiter of the environment.
     * 
     * @deprecated Use {@link Environment#setOption} with option "defaultFragmentDelimiter"
     * @param {String} fd The fragment delimiter character
     */
    
    function setDefaultFragmentDelimiter($fd)
    {
        if (is_string($fd) && strlen($fd) > 0) {
            $this->_options->defaultFragmentDelimiter = $fd;
        }
    }
    
    /**
     * Returns the default fragment delimiter of the environment.
     * 
     * @deprecated Use {@link Environment#getOption} with option "defaultFragmentDelimiter"
     * @returns {String} The fragment delimiter character
     */
    
    function getDefaultFragmentDelimiter()
    {
        return $this->_options->defaultFragmentDelimiter;
    }
    
    /**
     * Sets the URI of the default schema for the environment.
     * 
     * @deprecated Use {@link Environment#setOption} with option "defaultSchemaURI"
     * @param {String} uri The default schema URI
     */
    
    function setDefaultSchemaURI($uri)
    {
        if (is_string($uri)) {
            $this->_options->defaultSchemaURI = JSV::formatURI($uri);
        }
    }
    
    /**
     * Returns the default schema of the environment.
     * 
     * @returns {JSONSchema} The default schema
     */
    
    function getDefaultSchema()
    {
        return $this->findSchema($this->_options->defaultSchemaURI);
    }
    
    /**
     * Validates both the provided schema and the provided instance, and returns a {@link Report}. 
     * If the schema fails to validate, the instance will not be validated.
     * 
     * @param {JSONInstance|Any} instanceJSON The {@link JSONInstance} or JavaScript value to validate.
     * @param {JSONSchema|Any} schemaJSON The {@link JSONSchema} or JavaScript value to use in the validation. This will also be validated againt the schema's schema.
     * @returns {Report} The result of the validation
     */
    
    function validate($instanceJSON, $schemaJSON = null)
    {
        $report = new Report();
        
        try {
            $instance = $this->createInstance($instanceJSON);
            $report->instance = $instance;
        } catch (Exception $e) {
            $report->addError($e->uri, $e->schemaUri, $e->attribute, $e->getMessage(), $e->details);
        }
        
        try {
            $schema = $this->createSchema($schemaJSON);
            $report->schema = $schema;
            
            $schemaSchema = $schema->getSchema();
            $report->schemaSchema = $schemaSchema;
        } catch (Exception $e) {
            $report->addError($e->uri, $e->schemaUri, $e->attribute, $e->getMessage(), $e->details);
        }
        
        if ($schemaSchema) {
            $schemaSchema->validate($schema, $report);
        }
            
        if (count($report->errors)) {
            return $report;
        }
        
        return $schema->validate($instance, $report);
    }
    
    /**
     * @private
     */
    
    protected function _checkForInvalidInstances($stackSize, $schemaURI)
    {
        $result = array();
        $stack =
            array(
                array($schemaURI, $this->_schemas[$schemaURI])
            ); 
            $counter = 0;
        
        while ($counter++ < $stackSize && count($stack)) {
            $item = array_shift($stack);
            $uri = $item[0];
            $instance = $item[1];
            
            if ($instance instanceof JSONSchema) {
                if ($this->_schemas[$instance->getUri()] !== $instance) {
                    array_push($result, "Instance " . $uri . " does not match " . $instance->getUri());
                } else {
                    //$schema = $instance->getSchema();
                    //array_push($stack, array($uri . "/{schema}", $schema));
                    
                    $properties = $instance->getAttributes();
                    foreach ($properties as $key => $val) {
                        array_push($stack, array($uri . "/" . urlencode($key), $val));
                    }
                }
            } else if (is_object($instance)) {
                $properties = $instance;
                foreach (get_object_vars($properties) as $key => $val) {
                    if (isset($val)) {
                        array_push($stack, array($uri . "/" . urlencode($key), $val));
                    }
                }
            } else if (is_array($instance)) {
                $properties = $instance;
                foreach ($properties as $key => $val) {
                    array_push($stack, array($uri . "/" . urlencode($key), $val));
                }
            }
        }
        
        return count($result) ? $result : $counter;
    }

    function setId($id)
    {
        $this->_id = $id;
    }

    function getId()
    {
        return $this->_id;
    }

    function getSchemas()
    {
        return $this->_schemas;
    }
}
    
    /**
     * A globaly accessible object that provides the ability to create and manage {@link Environments},
     * as well as providing utility methods.
     *
     * Note: when porting JSV to PHP, remove all references to an "O" (the letter O) variable, this hack is
     * only necessary in javascript to make for (a in blah) work and is not needed in PHP
     * 
     * @namespace
     */
    
class JSV
{
    static protected $_environments = array();
    static protected $_defaultEnvironmentID = "";

    /**
     * Creates and returns a new {@link Environment} that is a clone of the environment registered with the provided ID.
     * If no environment ID is provided, the default environment is cloned.
     * 
     * @param {String} [id] The ID of the environment to clone. If <code>undefined</code>, the default environment ID is used.
     * @returns {Environment} A newly cloned {@link Environment}
     * @throws {Error} If there is no environment registered with the provided ID
     * @return class JsonSchema\Environment environment object
     */
    
    static function createEnvironment($id)
    {
        if (!$id) {
            $id = static::$_defaultEnvironmentID;
        }
        
        if (!static::$_environments[$id]) {
            throw new Exception("Unknown Environment ID");
        }
        //else
        return clone static::$_environments[$id];
    }

    /**
     * Registers the provided {@link Environment} with the provided ID.
     * 
     * @param {String} id The ID of the environment
     * @param {Environment} env The environment to register
     */
    
    static function registerEnvironment($id, $env)
    {
        if (!$id && $env) {
            $id = $env->_id;
        }
        if ($id && !static::$_environments[$id] && $env instanceof Environment) {
            $env->setId($id);
            static::$_environments[$id] = $env;
        }
    }

    /**
     * Sets which registered ID is the default environment.
     * 
     * @param {String} id The ID of the registered environment that is default
     * @throws {Error} If there is no registered environment with the provided ID
     */
    
    static function setDefaultEnvironmentID($id)
    {
        if (is_string($id)) {
            if (!static::$_environments[$id]) {
                throw new Exception("Unknown Environment ID");
            }
            
            static::$_defaultEnvironmentID = $id;
        }
    }

    /**
     * Returns the ID of the default environment.
     * 
     * @returns {String} The ID of the default environment
     */
    
    static function getDefaultEnvironmentID()
    {
        return static::$_defaultEnvironmentID;
    }

    //
    // Utility Functions
    //
    
    /**
     * Returns the name of the type of the provided value.
     *
     * @event //utility
     * @param {Any} o The value to determine the type of
     * @returns {String} The name of the type of the value
     */
    //typeOf : typeOf, use gettype
        
    /**
     * Return a new object that inherits all of the properties of the provided object.
     *
     * @event //utility
     * @param {Object} proto The prototype of the new object
     * @returns {Object} A new object that inherits all of the properties of the provided object
     */
    //createObject : createObject, use clone
        
    /**
     * Returns a new object with each property transformed by the iterator.
     *
     * @event //utility
     * @param {Object} obj The object to transform
     * @param {Function} iterator A function that returns the new value of the provided property
     * @returns {Object} A new object with each property transformed
     */
    // unnecessary

    /**
     * Returns a new array with each item transformed by the iterator.
     * 
     * @event //utility
     * @param {Array} arr The array to transform
     * @param {Function} iterator A function that returns the new value of the provided item
     * @param {Object} scope The value of <code>this</code> in the iterator
     * @returns {Array} A new array with each item transformed
     */
    //mapArray : mapArray, use array_map
    
    /**
     * Returns a new array that only contains the items allowed by the iterator.
     *
     * @event //utility
     * @param {Array} arr The array to filter
     * @param {Function} iterator The function that returns true if the provided property should be added to the array
     * @param {Object} scope The value of <code>this</code> within the iterator
     * @returns {Array} A new array that contains the items allowed by the iterator
     */
    //filterArray : filterArray, use array_filter
    
    /**
     * Returns the first index in the array that the provided item is located at.
     *
     * @event //utility
     * @param {Array} arr The array to search
     * @param {Any} o The item being searched for
     * @returns {Number} The index of the item in the array, or <code>-1</code> if not found
     */
    //searchArray : searchArray, use array_search
        
    /**
     * Returns an array representation of a value.
     * <ul>
     * <li>For array-like objects, the value will be casted as an Array type.</li>
     * <li>If an array is provided, the function will simply return the same array.</li>
     * <li>For a null or undefined value, the result will be an empty Array.</li>
     * <li>For all other values, the value will be the first element in a new Array. </li>
     * </ul>
     *
     * @event //utility
     * @param {Any} o The value to convert into an array
     * @returns {Array} The value as an array
     */
    //toArray : toArray, use settype($var, 'array');
    
    /**
     * Returns an array of the names of all properties of an object.
     * 
     * @event //utility
     * @param {Object|Array} o The object in question
     * @returns {Array} The names of all properties
     */
    //keys : keys, use get_object_vars
    
    /**
     * Mutates the array by pushing the provided value onto the array only if it is not already there.
     *
     * @event //utility
     * @param {Array} arr The array to modify
     * @param {Any} o The object to add to the array if it is not already there
     * @returns {Array} The provided array for chaining
     */
    static function pushUnique($arr, $o)
    {
        if (!in_array($o, $arr)) {
            $arr[] = $o;
        }
        return $arr;
    }
    
    /**
     * Mutates the array by removing the first item that matches the provided value in the array.
     *
     * @event //utility
     * @param {Array} arr The array to modify
     * @param {Any} o The object to remove from the array
     * @returns {Array} The provided array for chaining
     */
    //popFirst : popFirst, use array_udiff($arr, array($o))
    
    /**
     * Creates a copy of the target object.
     * <p>
     * This method will create a new instance of the target, and then mixin the properties of the target.
     * If <code>deep</code> is <code>true</code>, then each property will be cloned before mixin.
     * </p>
     * <p><b>Warning</b>: This is not a generic clone function, as it will only properly clone objects and arrays.</p>
     * 
     * @event //utility
     * @param {Any} o The value to clone 
     * @param {Boolean} [deep=false] If each property should be recursively cloned
     * @returns A cloned copy of the provided value
     */
    //clone : clone, use built-in PHP clone
    
    /**
     * Generates a pseudo-random UUID.
     * 
     * @event //utility
     * @returns {String} A new universally unique ID
     */
    static function randomUUID()
    {
        return sprintf('%04x%04x-%04x-%04x-%04x-%04x%04x%04x',
        
            // 32 bits for "time_low"
            mt_rand(0, 0xffff), mt_rand(0, 0xffff),
        
            // 16 bits for "time_mid"
            mt_rand(0, 0xffff),
        
            // 16 bits for "time_hi_and_version",
            // four most significant bits holds version number 4
            mt_rand(0, 0x0fff) | 0x4000,
        
            // 16 bits, 8 bits for "clk_seq_hi_res",
            // 8 bits for "clk_seq_low",
            // two most significant bits holds zero and one for variant DCE1.1
            mt_rand(0, 0x3fff) | 0x8000,
        
            // 48 bits for "node"
            mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0xffff)
        );
    }
    
    /**
     * Properly escapes a URI component for embedding into a URI string.
     * 
     * @event //utility
     * @param {String} str The URI component to escape
     * @returns {String} The escaped URI component
     */
    //escapeURIComponent : escapeURIComponent, use urlencode
    
    /**
     * Returns a URI that is formated for JSV. Currently, this only ensures that the URI ends with a hash tag (<code>#</code>).
     * 
     * @event //utility
     * @param {String} uri The URI to format
     * @returns {String} The URI formatted for JSV
     */
    static function formatURI($uri)
    {
        if ($uri && $uri[strlen($uri)-1] != '#') {
            $uri .= '#';
        }
        return $uri;
    }
        
    /**
     * Merges two schemas/instance together.
     * 
     * @event //utility
     * @param {JSONSchema|Any} base The old value to merge
     * @param {JSONSchema|Any} extra The new value to merge
     * @param {Boolean} extension If the merge is a JSON Schema extension
     * @return {Any} The modified base value
     */
     
    static function inherits($base, $extra = null, $extension = false)
    {        
        if ($extra === null) {
            if (is_object($base)) {
                if (is_callable($base)) {
                    return $base; // Closure cannot be cloned
                }
                return clone $base;
            }
            if (is_array($base)) {
                foreach ($base as $key => $val) {
                    if (is_object($val) || is_array($val)) {
                        $base[$key] = self::inherits($val);
                    }
                }
            }
            return $base;
        } else if ($base === null || gettype($base) != gettype($extra)) {
            if (is_object($extra)) {
                if (is_callable($extra)) {
                    return $extra; // Closure cannot be cloned
                }
                return clone $extra;
            }
            if (is_array($extra)) {
                foreach ($extra as $key => $val) {
                    if (is_object($val) || is_array($val)) {
                        $extra[$key] = self::inherits($val);
                    }
                }
            }
            return $extra;
        } else if (is_json_object($extra)) {
            if ($base instanceof JSONSchema) {
                $base = $base->getAttributes();
            }
            if ($extra instanceof JSONSchema) {
                $extra = $extra->getAttributes();
                if ($extra["extends"] && $extension && $extra["extends"] instanceof JSONSchema) {
                    $extra["extends"] = array($extra["extends"]);
                }
            }
            $child = $base;
            foreach ($extra as $x => $unused) {
                $child[$x] = self::inherits($base[$x], $extra[$x], $extension);
            }
            return $child;
        } else {
            if (is_object($extra)) {
                if (is_callable($extra)) {
                    return $extra; // Closure cannot be cloned
                }
                return clone $extra;
            }
            if (is_array($extra)) {
                foreach ($extra as $key => $val) {
                    if (is_object($val) || is_array($val)) {
                        $extra[$key] = self::inherits($val);
                    }
                }
            }
            return $extra;
        }
    }

	
	/**
	 * Warning: Not a generic clone function
	 * Produces a JSV acceptable clone
	 */
	
    static function dirtyClone($obj)
    {
		if ($obj instanceof JSONInstance) {
			$obj = $obj->getValue();
		}
        if (!is_object($obj) && !is_array($obj)) {
            return $obj;
        }
		
		if (is_object($obj)) {
            if (is_callable($obj)) {
                return $obj;
            }
            $obj = get_object_vars($obj);
        }
        $newObj = array();
        foreach ($obj as $key => $val) {
            $newObj[$key] = self::dirtyClone($val);
        }
        return $newObj;
	}
}
new JsonSchemaDraft01;
$env = JSV::createEnvironment("json-schema-draft-01");
$env->validate(new \stdClass);